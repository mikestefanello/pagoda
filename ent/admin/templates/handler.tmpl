{{/* Tell Intellij/GoLand to enable the autocompletion based on the *gen.Graph type. */}}
{{/* gotype: entgo.io/ent/entc/gen.Graph */}}

{{ define "admin/handler" }}
    // Code generated by ent, DO NOT EDIT.
    {{- $pkg := base $.Config.Package }}
    package admin

    import (
        "fmt"
        "strconv"

        "entgo.io/ent/dialect/sql"
        "github.com/labstack/echo/v4"

        "{{ $.Config.Package }}"
        {{- range $n := $.Nodes }}
            "{{ $.Config.Package }}/{{ $n.Package }}"
        {{- end }}
    )

    type Handler struct {
        client *{{ $pkg }}.Client
        itemsPerPage int
    }

    func NewHandler(client *{{ $pkg }}.Client, itemsPerPage int) *Handler {
        return &Handler{
            client: client,
            itemsPerPage: itemsPerPage,
        }
    }

    func (h *Handler) Create(ctx echo.Context, entityType string) error {
        switch entityType {
        {{- range $n := $.Nodes }}
        case "{{ $n.Name }}":
            return h.{{ $n.Name }}Create(ctx)
        {{- end }}
        default:
            return fmt.Errorf("unsupported entity type: %s", entityType)
        }
    }

    func (h *Handler) Get(ctx echo.Context, entityType string, id int) error {
        // TODO
        switch entityType {
        {{- range $n := $.Nodes }}
        case "{{ $n.Name }}":
            return h.{{ $n.Name }}Get(ctx, id)
        {{- end }}
        default:
            return fmt.Errorf("unsupported entity type: %s", entityType)
        }
    }

    func (h *Handler) Delete(ctx echo.Context, entityType string, id int) error {
        switch entityType {
        {{- range $n := $.Nodes }}
        case "{{ $n.Name }}":
            return h.{{ $n.Name }}Delete(ctx, id)
        {{- end }}
        default:
            return fmt.Errorf("unsupported entity type: %s", entityType)
        }
    }

    func (h *Handler) Update(ctx echo.Context, entityType string, id int) error {
        switch entityType {
        {{- range $n := $.Nodes }}
        case "{{ $n.Name }}":
            return h.{{ $n.Name }}Update(ctx, id)
        {{- end }}
        default:
            return fmt.Errorf("unsupported entity type: %s", entityType)
        }
    }

    func (h *Handler) List(ctx echo.Context, entityType string) (*EntityList, error) {
        switch entityType {
        {{- range $n := $.Nodes }}
        case "{{ $n.Name }}":
            return h.{{ $n.Name }}List(ctx)
        {{- end }}
        default:
            return nil, fmt.Errorf("unsupported entity type: %s", entityType)
        }
    }

    {{ range $n := $.Nodes }}
        func (h *Handler) {{ $n.Name }}Create(ctx echo.Context) error {
            var payload {{ $n.Name }}
            if err := ctx.Bind(&payload); err != nil {
                return err
            }

            op := h.client.{{ $n.Name }}.Create()
            {{- range $f := $n.Fields }}
                op.Set{{ fieldName $f.Name }}(payload.{{ fieldName $f.Name }})
            {{- end }}
            {{- range $e := $n.Edges }}
                {{- if not $e.Inverse}}
                   // op.Set{{ fieldName $e.Name }}ID(payload.{{ fieldName $e.Name }})
                {{- end }}
            {{- end }}
            _, err := op.Save(ctx.Request().Context())
            return err
        }

        func (h *Handler) {{ $n.Name }}Update(ctx echo.Context, id int) error {
            entity, err := h.client.{{ $n.Name }}.Get(ctx.Request().Context(), id)
            if err != nil {
                return err
            }

            var payload {{ $n.Name }}
            if err = ctx.Bind(&payload); err != nil {
                return err
            }

            op := entity.Update()
            {{- range $f := $n.Fields }}
                {{- if not $f.Immutable }}
                    op.Set{{ fieldName $f.Name }}(payload.{{ fieldName $f.Name }})
                {{- end }}
            {{- end }}
            {{- range $e := $n.Edges }}
                {{- if not $e.Inverse}}
                    // op.Set{{ fieldName $e.Name }}ID(payload.{{ fieldName $e.Name }})
                {{- end }}
            {{- end }}
            _, err = op.Save(ctx.Request().Context())
            return err
        }

        func (h *Handler) {{ $n.Name }}Delete(ctx echo.Context, id int) error {
            return h.client.{{ $n.Name }}.DeleteOneID(id).
                Exec(ctx.Request().Context())
        }

        func (h *Handler) {{ $n.Name }}List(ctx echo.Context) (*EntityList, error) {
            res, err := h.client.{{ $n.Name }}.
                Query().
                Limit(h.itemsPerPage+1).
                Offset(h.getOffset(ctx)).
                Order({{ $n.Package }}.ByID(sql.OrderDesc())).
                All(ctx.Request().Context())

            if err != nil {
                return nil, err
            }

            list := &EntityList{
                Columns: []string{
                    {{- range $f := $n.Fields }}
                        {{- if not $f.Sensitive }}
                            "{{ fieldLabel $f.Name }}",
                        {{- end }}
                    {{- end }}
                    {{- range $e := $n.Edges }}
                        {{- if not $e.Inverse}}
                            // "{{ fieldLabel $e.Name }}", ?
                        {{- end }}
                    {{- end }}
                },
                Entities: make([]EntityValues, 0, len(res)),
                HasNextPage: len(res) > h.itemsPerPage,
            }

            for i := 0; i <= len(res)-1; i++ {
                list.Entities = append(list.Entities, EntityValues{
                    ID: res[i].ID,
                    Values: []string{
                    {{- range $f := $n.Fields }}
                        {{- if not $f.Sensitive }}
                            {{- if eq $f.Type.String "string" }}
                                res[i].{{ fieldName $f.Name }},
                            {{- else }}
                                fmt.Sprint(res[i].{{ fieldName $f.Name }}),
                            {{- end }}
                        {{- end }}
                    {{- end }}
                    {{- range $e := $n.Edges }}
                        {{- if not $e.Inverse}}
                            // TODO {{ fieldName $e.Name }} ?
                        {{- end }}
                    {{- end }}
                    },
                })
            }

            return list, err
        }

        func (h *Handler) {{ $n.Name }}Get(ctx echo.Context, id int) error {
            _, err := h.client.{{ $n.Name }}.Get(ctx.Request().Context(), id)
            if err != nil {
                return err
            }

            // TODO
            return nil
        }
    {{ end }}

    func (h *Handler) getOffset(ctx echo.Context) int {
        if page, err := strconv.Atoi(ctx.QueryParam("page")); err == nil {
            if page > 1 {
                return (page-1) * h.itemsPerPage
            }
        }
        return 0
    }

{{ end }}