// Code generated by ent, DO NOT EDIT.
package admin

import (
	"fmt"
	"strconv"

	"entgo.io/ent/dialect/sql"
	"github.com/labstack/echo/v4"

	"github.com/mikestefanello/pagoda/ent"
	"github.com/mikestefanello/pagoda/ent/passwordtoken"
	"github.com/mikestefanello/pagoda/ent/user"
)

type Handler struct {
	client *ent.Client
	Config HandlerConfig
}

func NewHandler(client *ent.Client, cfg HandlerConfig) *Handler {
	return &Handler{
		client: client,
		Config: cfg,
	}
}

func (h *Handler) Create(ctx echo.Context, entityType string) error {
	switch entityType {
	case "PasswordToken":
		return h.PasswordTokenCreate(ctx)
	case "User":
		return h.UserCreate(ctx)
	default:
		return fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) Get(ctx echo.Context, entityType string, id int) error {
	// TODO
	switch entityType {
	case "PasswordToken":
		return h.PasswordTokenGet(ctx, id)
	case "User":
		return h.UserGet(ctx, id)
	default:
		return fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) Delete(ctx echo.Context, entityType string, id int) error {
	switch entityType {
	case "PasswordToken":
		return h.PasswordTokenDelete(ctx, id)
	case "User":
		return h.UserDelete(ctx, id)
	default:
		return fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) Update(ctx echo.Context, entityType string, id int) error {
	switch entityType {
	case "PasswordToken":
		return h.PasswordTokenUpdate(ctx, id)
	case "User":
		return h.UserUpdate(ctx, id)
	default:
		return fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) List(ctx echo.Context, entityType string) (*EntityList, error) {
	switch entityType {
	case "PasswordToken":
		return h.PasswordTokenList(ctx)
	case "User":
		return h.UserList(ctx)
	default:
		return nil, fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) PasswordTokenCreate(ctx echo.Context) error {
	var payload PasswordToken
	if err := ctx.Bind(&payload); err != nil {
		return err
	}

	op := h.client.PasswordToken.Create()
	op.SetHash(payload.Hash)
	op.SetUserID(payload.UserID)
	op.SetCreatedAt(payload.CreatedAt)
	// op.SetUserID(payload.User)
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) PasswordTokenUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.PasswordToken.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload PasswordToken
	if err = ctx.Bind(&payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetHash(payload.Hash)
	op.SetUserID(payload.UserID)
	op.SetCreatedAt(payload.CreatedAt)
	// op.SetUserID(payload.User)
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) PasswordTokenDelete(ctx echo.Context, id int) error {
	return h.client.PasswordToken.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) PasswordTokenList(ctx echo.Context) (*EntityList, error) {
	res, err := h.client.PasswordToken.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(h.getOffset(ctx)).
		Order(passwordtoken.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"User id",
			"Created at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				fmt.Sprint(res[i].UserID),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) PasswordTokenGet(ctx echo.Context, id int) error {
	_, err := h.client.PasswordToken.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	// TODO
	return nil
}

func (h *Handler) UserCreate(ctx echo.Context) error {
	var payload User
	if err := ctx.Bind(&payload); err != nil {
		return err
	}

	op := h.client.User.Create()
	op.SetName(payload.Name)
	op.SetEmail(payload.Email)
	op.SetPassword(payload.Password)
	op.SetVerified(payload.Verified)
	op.SetCreatedAt(payload.CreatedAt)
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) UserUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.User.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload User
	if err = ctx.Bind(&payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetName(payload.Name)
	op.SetEmail(payload.Email)
	op.SetPassword(payload.Password)
	op.SetVerified(payload.Verified)
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) UserDelete(ctx echo.Context, id int) error {
	return h.client.User.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) UserList(ctx echo.Context) (*EntityList, error) {
	res, err := h.client.User.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(h.getOffset(ctx)).
		Order(user.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Name",
			"Email",
			"Verified",
			"Created at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].Name,
				res[i].Email,
				fmt.Sprint(res[i].Verified),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) UserGet(ctx echo.Context, id int) error {
	_, err := h.client.User.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	// TODO
	return nil
}

func (h *Handler) getOffset(ctx echo.Context) int {
	if page, err := strconv.Atoi(ctx.QueryParam(h.Config.PageQueryKey)); err == nil {
		if page > 1 {
			return (page - 1) * h.Config.ItemsPerPage
		}
	}
	return 0
}
