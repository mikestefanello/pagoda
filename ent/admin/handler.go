// Code generated by ent, DO NOT EDIT.
package admin

import (
	"fmt"
	"net/url"
	"strconv"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/labstack/echo/v4"

	"github.com/mikestefanello/pagoda/ent"
	"github.com/mikestefanello/pagoda/ent/passwordtoken"
	"github.com/mikestefanello/pagoda/ent/user"
)

type Handler struct {
	client *ent.Client
	Config HandlerConfig
}

func NewHandler(client *ent.Client, cfg HandlerConfig) *Handler {
	return &Handler{
		client: client,
		Config: cfg,
	}
}

func (h *Handler) Create(ctx echo.Context, entityType string) error {
	switch entityType {
	case "PasswordToken":
		return h.PasswordTokenCreate(ctx)
	case "User":
		return h.UserCreate(ctx)
	default:
		return fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) Get(ctx echo.Context, entityType string, id int) (url.Values, error) {
	switch entityType {
	case "PasswordToken":
		return h.PasswordTokenGet(ctx, id)
	case "User":
		return h.UserGet(ctx, id)
	default:
		return nil, fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) Delete(ctx echo.Context, entityType string, id int) error {
	switch entityType {
	case "PasswordToken":
		return h.PasswordTokenDelete(ctx, id)
	case "User":
		return h.UserDelete(ctx, id)
	default:
		return fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) Update(ctx echo.Context, entityType string, id int) error {
	switch entityType {
	case "PasswordToken":
		return h.PasswordTokenUpdate(ctx, id)
	case "User":
		return h.UserUpdate(ctx, id)
	default:
		return fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) List(ctx echo.Context, entityType string) (*EntityList, error) {
	switch entityType {
	case "PasswordToken":
		return h.PasswordTokenList(ctx)
	case "User":
		return h.UserList(ctx)
	default:
		return nil, fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) PasswordTokenCreate(ctx echo.Context) error {
	var payload PasswordToken
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.PasswordToken.Create()
	if payload.Hash != nil {
		op.SetHash(*payload.Hash)
	}
	op.SetUserID(payload.UserID)
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) PasswordTokenUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.PasswordToken.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload PasswordToken
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	if payload.Hash != nil {
		op.SetHash(*payload.Hash)
	}
	op.SetUserID(payload.UserID)
	if payload.CreatedAt == nil {
		var empty time.Time
		op.SetCreatedAt(empty)
	} else {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) PasswordTokenDelete(ctx echo.Context, id int) error {
	return h.client.PasswordToken.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) PasswordTokenList(ctx echo.Context) (*EntityList, error) {
	res, err := h.client.PasswordToken.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(h.getOffset(ctx)).
		Order(passwordtoken.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"User ID",
			"Created at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				fmt.Sprint(res[i].UserID),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) PasswordTokenGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.PasswordToken.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("user_id", fmt.Sprint(entity.UserID))
	v.Set("created_at", entity.CreatedAt.Format(time.RFC3339))
	return v, err
}

func (h *Handler) UserCreate(ctx echo.Context) error {
	var payload User
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.User.Create()
	op.SetName(payload.Name)
	op.SetEmail(payload.Email)
	if payload.Password != nil {
		op.SetPassword(*payload.Password)
	}
	op.SetVerified(payload.Verified)
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) UserUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.User.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload User
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetName(payload.Name)
	op.SetEmail(payload.Email)
	if payload.Password != nil {
		op.SetPassword(*payload.Password)
	}
	op.SetVerified(payload.Verified)
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) UserDelete(ctx echo.Context, id int) error {
	return h.client.User.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) UserList(ctx echo.Context) (*EntityList, error) {
	res, err := h.client.User.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(h.getOffset(ctx)).
		Order(user.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Name",
			"Email",
			"Verified",
			"Created at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].Name,
				res[i].Email,
				fmt.Sprint(res[i].Verified),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) UserGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.User.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("name", entity.Name)
	v.Set("email", entity.Email)
	v.Set("verified", fmt.Sprint(entity.Verified))
	return v, err
}

func (h *Handler) getOffset(ctx echo.Context) int {
	if page, err := strconv.Atoi(ctx.QueryParam(h.Config.PageQueryKey)); err == nil {
		if page > 1 {
			return (page - 1) * h.Config.ItemsPerPage
		}
	}
	return 0
}

func (h *Handler) bind(ctx echo.Context, entity any) error {
	// Remove empty field values so Echo's bind does to fail when trying to parse things like
	// times, etc.
	for k, v := range ctx.Request().Form {
		if len(v) == 1 && len(v[0]) == 0 {
			delete(ctx.Request().Form, k)
		}
	}
	return ctx.Bind(entity)
}
