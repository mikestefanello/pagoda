// Code generated by ent, DO NOT EDIT.

package ogent

import (
	"context"

	"github.com/go-faster/jx"
	"github.com/mikestefanello/pagoda/ent"
	"github.com/mikestefanello/pagoda/ent/passwordtoken"
	"github.com/mikestefanello/pagoda/ent/user"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreatePasswordToken handles POST /password-tokens requests.
func (h *OgentHandler) CreatePasswordToken(ctx context.Context, req *CreatePasswordTokenReq) (CreatePasswordTokenRes, error) {
	b := h.client.PasswordToken.Create()
	// Add all fields.
	b.SetHash(req.Hash)
	b.SetCreatedAt(req.CreatedAt)
	// Add all edges.
	b.SetUserID(req.User)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		// Let the server handle the error.
		return nil, err
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.PasswordToken.Query().Where(passwordtoken.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewPasswordTokenCreate(e), nil
}

// ReadPasswordToken handles GET /password-tokens/{id} requests.
func (h *OgentHandler) ReadPasswordToken(ctx context.Context, params ReadPasswordTokenParams) (ReadPasswordTokenRes, error) {
	q := h.client.PasswordToken.Query().Where(passwordtoken.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		// Let the server handle the error.
		return nil, err
	}
	return NewPasswordTokenRead(e), nil
}

// UpdatePasswordToken handles PATCH /password-tokens/{id} requests.
func (h *OgentHandler) UpdatePasswordToken(ctx context.Context, req *UpdatePasswordTokenReq, params UpdatePasswordTokenParams) (UpdatePasswordTokenRes, error) {
	b := h.client.PasswordToken.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Hash.Get(); ok {
		b.SetHash(v)
	}
	if v, ok := req.CreatedAt.Get(); ok {
		b.SetCreatedAt(v)
	}
	// Add all edges.
	if v, ok := req.User.Get(); ok {
		b.SetUserID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		// Let the server handle the error.
		return nil, err
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.PasswordToken.Query().Where(passwordtoken.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewPasswordTokenUpdate(e), nil
}

// DeletePasswordToken handles DELETE /password-tokens/{id} requests.
func (h *OgentHandler) DeletePasswordToken(ctx context.Context, params DeletePasswordTokenParams) (DeletePasswordTokenRes, error) {
	err := h.client.PasswordToken.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		// Let the server handle the error.
		return nil, err
	}
	return new(DeletePasswordTokenNoContent), nil

}

// ListPasswordToken handles GET /password-tokens requests.
func (h *OgentHandler) ListPasswordToken(ctx context.Context, params ListPasswordTokenParams) (ListPasswordTokenRes, error) {
	q := h.client.PasswordToken.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		// Let the server handle the error.
		return nil, err
	}
	r := NewPasswordTokenLists(es)
	return (*ListPasswordTokenOKApplicationJSON)(&r), nil
}

// ReadPasswordTokenUser handles GET /password-tokens/{id}/user requests.
func (h *OgentHandler) ReadPasswordTokenUser(ctx context.Context, params ReadPasswordTokenUserParams) (ReadPasswordTokenUserRes, error) {
	q := h.client.PasswordToken.Query().Where(passwordtoken.IDEQ(params.ID)).QueryUser()
	e, err := q.Only(ctx)
	if err != nil {
		// Let the server handle the error.
		return nil, err
	}
	return NewPasswordTokenUserRead(e), nil
}

// CreateUser handles POST /users requests.
func (h *OgentHandler) CreateUser(ctx context.Context, req *CreateUserReq) (CreateUserRes, error) {
	b := h.client.User.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetEmail(req.Email)
	b.SetPassword(req.Password)
	b.SetVerified(req.Verified)
	b.SetCreatedAt(req.CreatedAt)
	// Add all edges.
	b.AddOwnerIDs(req.Owner...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		// Let the server handle the error.
		return nil, err
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserCreate(e), nil
}

// ReadUser handles GET /users/{id} requests.
func (h *OgentHandler) ReadUser(ctx context.Context, params ReadUserParams) (ReadUserRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		// Let the server handle the error.
		return nil, err
	}
	return NewUserRead(e), nil
}

// UpdateUser handles PATCH /users/{id} requests.
func (h *OgentHandler) UpdateUser(ctx context.Context, req *UpdateUserReq, params UpdateUserParams) (UpdateUserRes, error) {
	b := h.client.User.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Email.Get(); ok {
		b.SetEmail(v)
	}
	if v, ok := req.Password.Get(); ok {
		b.SetPassword(v)
	}
	if v, ok := req.Verified.Get(); ok {
		b.SetVerified(v)
	}
	// Add all edges.
	if req.Owner != nil {
		b.ClearOwner().AddOwnerIDs(req.Owner...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		// Let the server handle the error.
		return nil, err
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserUpdate(e), nil
}

// DeleteUser handles DELETE /users/{id} requests.
func (h *OgentHandler) DeleteUser(ctx context.Context, params DeleteUserParams) (DeleteUserRes, error) {
	err := h.client.User.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		// Let the server handle the error.
		return nil, err
	}
	return new(DeleteUserNoContent), nil

}

// ListUser handles GET /users requests.
func (h *OgentHandler) ListUser(ctx context.Context, params ListUserParams) (ListUserRes, error) {
	q := h.client.User.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		// Let the server handle the error.
		return nil, err
	}
	r := NewUserLists(es)
	return (*ListUserOKApplicationJSON)(&r), nil
}

// ListUserOwner handles GET /users/{id}/owner requests.
func (h *OgentHandler) ListUserOwner(ctx context.Context, params ListUserOwnerParams) (ListUserOwnerRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryOwner()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		// Let the server handle the error.
		return nil, err
	}
	r := NewUserOwnerLists(es)
	return (*ListUserOwnerOKApplicationJSON)(&r), nil
}
