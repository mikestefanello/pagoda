// Code generated by ent, DO NOT EDIT.

package ogent

import "github.com/mikestefanello/pagoda/ent"

func NewPasswordTokenCreate(e *ent.PasswordToken) *PasswordTokenCreate {
	if e == nil {
		return nil
	}
	var ret PasswordTokenCreate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	return &ret
}

func NewPasswordTokenCreates(es []*ent.PasswordToken) []PasswordTokenCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]PasswordTokenCreate, len(es))
	for i, e := range es {
		r[i] = NewPasswordTokenCreate(e).Elem()
	}
	return r
}

func (pt *PasswordTokenCreate) Elem() PasswordTokenCreate {
	if pt == nil {
		return PasswordTokenCreate{}
	}
	return *pt
}

func NewPasswordTokenList(e *ent.PasswordToken) *PasswordTokenList {
	if e == nil {
		return nil
	}
	var ret PasswordTokenList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	return &ret
}

func NewPasswordTokenLists(es []*ent.PasswordToken) []PasswordTokenList {
	if len(es) == 0 {
		return nil
	}
	r := make([]PasswordTokenList, len(es))
	for i, e := range es {
		r[i] = NewPasswordTokenList(e).Elem()
	}
	return r
}

func (pt *PasswordTokenList) Elem() PasswordTokenList {
	if pt == nil {
		return PasswordTokenList{}
	}
	return *pt
}

func NewPasswordTokenRead(e *ent.PasswordToken) *PasswordTokenRead {
	if e == nil {
		return nil
	}
	var ret PasswordTokenRead
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	return &ret
}

func NewPasswordTokenReads(es []*ent.PasswordToken) []PasswordTokenRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]PasswordTokenRead, len(es))
	for i, e := range es {
		r[i] = NewPasswordTokenRead(e).Elem()
	}
	return r
}

func (pt *PasswordTokenRead) Elem() PasswordTokenRead {
	if pt == nil {
		return PasswordTokenRead{}
	}
	return *pt
}

func NewPasswordTokenUpdate(e *ent.PasswordToken) *PasswordTokenUpdate {
	if e == nil {
		return nil
	}
	var ret PasswordTokenUpdate
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	return &ret
}

func NewPasswordTokenUpdates(es []*ent.PasswordToken) []PasswordTokenUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]PasswordTokenUpdate, len(es))
	for i, e := range es {
		r[i] = NewPasswordTokenUpdate(e).Elem()
	}
	return r
}

func (pt *PasswordTokenUpdate) Elem() PasswordTokenUpdate {
	if pt == nil {
		return PasswordTokenUpdate{}
	}
	return *pt
}

func NewPasswordTokenUserRead(e *ent.User) *PasswordTokenUserRead {
	if e == nil {
		return nil
	}
	var ret PasswordTokenUserRead
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Email = e.Email
	ret.Verified = e.Verified
	ret.CreatedAt = e.CreatedAt
	return &ret
}

func NewPasswordTokenUserReads(es []*ent.User) []PasswordTokenUserRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]PasswordTokenUserRead, len(es))
	for i, e := range es {
		r[i] = NewPasswordTokenUserRead(e).Elem()
	}
	return r
}

func (u *PasswordTokenUserRead) Elem() PasswordTokenUserRead {
	if u == nil {
		return PasswordTokenUserRead{}
	}
	return *u
}

func NewUserCreate(e *ent.User) *UserCreate {
	if e == nil {
		return nil
	}
	var ret UserCreate
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Email = e.Email
	ret.Verified = e.Verified
	ret.CreatedAt = e.CreatedAt
	return &ret
}

func NewUserCreates(es []*ent.User) []UserCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserCreate, len(es))
	for i, e := range es {
		r[i] = NewUserCreate(e).Elem()
	}
	return r
}

func (u *UserCreate) Elem() UserCreate {
	if u == nil {
		return UserCreate{}
	}
	return *u
}

func NewUserList(e *ent.User) *UserList {
	if e == nil {
		return nil
	}
	var ret UserList
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Email = e.Email
	ret.Verified = e.Verified
	ret.CreatedAt = e.CreatedAt
	return &ret
}

func NewUserLists(es []*ent.User) []UserList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserList, len(es))
	for i, e := range es {
		r[i] = NewUserList(e).Elem()
	}
	return r
}

func (u *UserList) Elem() UserList {
	if u == nil {
		return UserList{}
	}
	return *u
}

func NewUserRead(e *ent.User) *UserRead {
	if e == nil {
		return nil
	}
	var ret UserRead
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Email = e.Email
	ret.Verified = e.Verified
	ret.CreatedAt = e.CreatedAt
	return &ret
}

func NewUserReads(es []*ent.User) []UserRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserRead, len(es))
	for i, e := range es {
		r[i] = NewUserRead(e).Elem()
	}
	return r
}

func (u *UserRead) Elem() UserRead {
	if u == nil {
		return UserRead{}
	}
	return *u
}

func NewUserUpdate(e *ent.User) *UserUpdate {
	if e == nil {
		return nil
	}
	var ret UserUpdate
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Email = e.Email
	ret.Verified = e.Verified
	ret.CreatedAt = e.CreatedAt
	return &ret
}

func NewUserUpdates(es []*ent.User) []UserUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserUpdate, len(es))
	for i, e := range es {
		r[i] = NewUserUpdate(e).Elem()
	}
	return r
}

func (u *UserUpdate) Elem() UserUpdate {
	if u == nil {
		return UserUpdate{}
	}
	return *u
}

func NewUserOwnerList(e *ent.PasswordToken) *UserOwnerList {
	if e == nil {
		return nil
	}
	var ret UserOwnerList
	ret.ID = e.ID
	ret.CreatedAt = e.CreatedAt
	return &ret
}

func NewUserOwnerLists(es []*ent.PasswordToken) []UserOwnerList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserOwnerList, len(es))
	for i, e := range es {
		r[i] = NewUserOwnerList(e).Elem()
	}
	return r
}

func (pt *UserOwnerList) Elem() UserOwnerList {
	if pt == nil {
		return UserOwnerList{}
	}
	return *pt
}
